!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).WebSerialReceiptPrinter=e()}(this,(function(){"use strict";class t{constructor(t){this._events={}}on(t,e){this._events[t]=this._events[t]||[],this._events[t].push(e)}emit(t,...e){let n=this._events[t];n&&n.forEach((t=>{setTimeout((()=>t(...e)),0)}))}}return class{constructor(e){this._internal={emitter:new t,port:null,reader:null,profile:null,queue:[],running:!1,closing:!1,options:Object.assign({baudRate:9600,bufferSize:255,dataBits:8,flowControl:"none",parity:"none",stopBits:1},e)},navigator.serial.addEventListener("disconnect",(t=>{this._internal.port==t.target&&this._internal.emitter.emit("disconnected")}))}async connect(){try{let t=await navigator.serial.requestPort();t&&await this.open(t)}catch(t){console.log("Could not connect! "+t)}}async reconnect(t){if(!t.vendorId||!t.productId)return;let e=(await navigator.serial.getPorts()).filter((e=>{let n=e.getInfo();return n.usbVendorId==t.vendorId&&n.usbProductId==t.productId}));1==e.length&&await this.open(e[0])}async open(t){this._internal.port=t,this._internal.closing=!1,await this._internal.port.open(this._internal.options);let e=this._internal.port.getInfo();this._internal.emitter.emit("connected",{type:"serial",vendorId:e.usbVendorId||null,productId:e.usbProductId||null,language:null,codepageMapping:null})}async disconnect(){this._internal.port&&(this._internal.closing=!0,this._internal.reader.cancel(),await this._internal.reader.closed,await this._internal.port.close(),this._internal.port=null,this._internal.profile=null,this._internal.emitter.emit("disconnected"))}async listen(){for(;this._internal.port.readable&&!1===this._internal.closing;){this._internal.reader=this._internal.port.readable.getReader();try{for(;;){const{value:t,done:e}=await this._internal.reader.read();if(e)break;t&&this._internal.emitter.emit("data",t)}}catch(t){}finally{this._internal.reader.releaseLock()}}}async print(t){this._internal.queue.push(t),this.run()}async run(){if(this._internal.closing)return;if(this._internal.running)return;this._internal.running=!0;const t=this._internal.port.writable.getWriter();let e;for(;e=this._internal.queue.shift();)await t.write(e);t.releaseLock(),this._internal.running=!1}addEventListener(t,e){this._internal.emitter.on(t,e)}}}));
