class t{constructor(t){this._events={}}on(t,e){this._events[t]=this._events[t]||[],this._events[t].push(e)}emit(t,...e){let s=this._events[t];s&&s.forEach((t=>{setTimeout((()=>t(...e)),0)}))}}class e{}class s extends e{#t;#e={};#s=null;#i=null;#n=[];#r={running:!1,closing:!1};constructor(e){super(),this.#t=new t,this.#e=Object.assign({baudRate:9600,bufferSize:255,dataBits:8,flowControl:"none",parity:"none",stopBits:1},e),navigator.serial.addEventListener("disconnect",(t=>{this.#s==t.target&&this.#t.emit("disconnected")}))}async connect(){try{let t=await navigator.serial.requestPort();t&&await this.#a(t)}catch(t){console.log("Could not connect! "+t)}}async reconnect(t){if(!t.vendorId||!t.productId)return;let e=(await navigator.serial.getPorts()).filter((e=>{let s=e.getInfo();return s.usbVendorId==t.vendorId&&s.usbProductId==t.productId}));1==e.length&&await this.#a(e[0])}async#a(t){this.#s=t,this.#r.closing=!1,await this.#s.open(this.#e);let e=this.#s.getInfo();this.#t.emit("connected",{type:"serial",vendorId:e.usbVendorId||null,productId:e.usbProductId||null,language:null,codepageMapping:null})}async disconnect(){this.#s&&(this.#r.closing=!0,this.#i.cancel(),await this.#i.closed,await this.#s.close(),this.#s=null,this.#t.emit("disconnected"))}async listen(){return this.#o(),!0}async#o(){for(;this.#s.readable&&!1===this.#r.closing;){this.#i=this.#s.readable.getReader();try{for(;;){const{value:t,done:e}=await this.#i.read();if(e)break;t&&this.#t.emit("data",t)}}catch(t){}finally{this.#i.releaseLock()}}}async print(t){this.#n.push(t),this.run()}async run(){if(this.#r.closing)return;if(this.#r.running)return;this.#r.running=!0;const t=this.#s.writable.getWriter();let e;for(;e=this.#n.shift();)await t.write(e);t.releaseLock(),this.#r.running=!1}addEventListener(t,e){this.#t.on(t,e)}}export{s as default};
//# sourceMappingURL=webserial-receipt-printer.esm.js.map
